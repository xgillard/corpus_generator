# CORPUS-GENERATOR

## Abstract
This is the micro service which generates the dynamic corpus for one given
student. A corpus is generated by issuing a request to:

```
http:://{server}/bz2/<secret>/<corpus_id>/<username>/<size>/<whatever_filename>
```

or (to get the corpus in plaintext)

```
http:://{server}/txt/<secret>/<corpus_id>/<username>/<size>/<whatever_filename>
```

Where:
* `{server}` stands for the ip address/dns name of the machine where
  this service is deployed.
* `<secret>` is a key which is changed each academic year (actually, it does
  not even need to be secret). Its purpose is to make sure that a student
  taking the same class and project several years in a row receives different
  corpora each year. This makes the inginous tasks easier to reuse over time.
* `<corpus_id>` is the name of a base corpus (one that has been placed in
  the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
  if I want to generate a subset of the `public/corpus/p1_train.txt` bases
  corpus, I need to specify the `p1_train` corpus key.
* `<size>` is the size (in number of lines) of the corpus you want to generate
* `<username>` is the name of the user whose corpus is to be generated.
* `<whatever_filename>` is the name of the file if it were to be downloaded

## Why use this server implementation rather than the python one ?
The python implementation based on `flask` is nice and simple. It gets the job 
done easily. However, this implementation is **much** faster than the one in
python. It is written in rust and leverages multiple threads along with an async
programming model which means it can even serve multiple clients on the same
thread.

## Why should I care ?
Since this server is going to be used by both the students (low traffic) and the 
inginious containers each time a task is evaluated (lots of concurrent requests);
it is desirable to use a server which is able to better cope with the load and
wont be DoS'ed near the project deadline.

An other advantage, stems from the fact that this server has been written with 
`rust + actix` which is considered ok for prod whereas `flask` still warns 
against it. Plus, rust is a much safer language than python. Which means our
machine will not be used to mine bitcoins instead of serving cutom student corpora.

## Installation
Installing the server is a no brainer: all it takes is to compile the code and
then run it. Given this server is written, in rust, you will need to have the
compiler installed. I already took care of that part. But in case you need to
do it on another machine, here is how you install it: you can just follow the 
steps detailed on https://www.rust-lang.org/. Or you can simply execute the 
following line in your shell: 
```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

After that, the compilation is done with 
```
cargo build --release
```

That's it. Your compiled server is located in `$PROJECT/target/release/`

## Execution
Running the server is dead simple: you just execute the executable from a 
directory where `public/corpus/` is a folder containing the corpora that can
be customized. 

In order to make the service publicly available, and to make the server bind
a chosen port you only need to edit the configuration file (`Rocket.toml`) and
then restart the server (`server.sh restart`).

## Techical Note
Because the VM on the INGI cloud use ipv6 only, and because github.com does not
support ipv6 at all, I did vendor all the dependency sources. This way the 
project can be built without requiring any access to the external world. Should
you change any of the dependency, and need to do the same; here is how you do it

```
# On your local machine, before scp onto the destination
cargo vendor

# Copy the few lines it tells you to in `.cargo/config.toml`
# You are now done: you can pack your application an upload it to your 
# ingi-cloud VM.
```

## Opening the Service to the world
No need to fiddle with ip6tables: that won't work. Our beloved sysadmins are
the ones holding the leads to open ports on your machine and make it globally
routable. All you need to do is to create a ticket and ask them to provide your
machine with: 
  - a dns name
  - open ports 80 (http) and/or 443 (https)

## Offering the service through a secure connection
It is likely that student browsers will complain about the fact that your 
service is not available via a secure connection (and might refuse to download
the generated content). So the next thing you'll want to do is to configure
the web service to run over https. 

This is extremely simple: all you need to do is to: 
1. Generate a key and Certificate request 
```
openssl req -new -newkey rsa:2048 -nodes -keyout linfo2263.key -out linfo2263.csr
```
2. Have your certificate request (csr) signed by the admins
3. Update the file `Rocket.toml` make sure the tls configurations points towards
   your signed certificate.