# CORPUS-GENERATOR

## Abstract
This is the micro service which generates the dynamic corpus for one given
student. A corpus is generated by issuing a request to:

```
http:://{server}/bz2/<secret>/<corpus_id>/<username>/<size>/download.txt.bz2
```

or (to get the corpus in plaintext)

```
http:://{server}/txt/<secret>/<corpus_id>/<username>/<size>/download.txt
```

Where:
* `{server}` stands for the ip address/dns name of the machine where
  this service is deployed.
* `<secret>` is a key which is changed each academic year (actually, it does
  not even need to be secret). Its purpose is to make sure that a student
  taking the same class and project several years in a row receives different
  corpora each year. This makes the inginous tasks easier to reuse over time.
* `<corpus_id>` is the name of a base corpus (one that has been placed in
  the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
  if I want to generate a subset of the `public/corpus/p1_train.txt` base
  corpus, I need to specify the `p1_train` corpus key.
* `<size>` is the size (in number of lines) of the corpus you want to generate
* `<username>` is the name of the user whose corpus is to be generated.

## Why use this server implementation rather than the python one ?
The python implementation based on `flask` is nice and simple. It gets the job 
done easily. However, this implementation is **much** faster than the one in
python. It is written in rust and leverages multiple threads along with an async
programming model which means it can even serve multiple clients on the same
thread.

## Why should I care ?
Since this server is going to be used by both the students (low traffic) and the 
inginious containers each time a task is evaluated (lots of concurrent requests);
it is desirable to use a server which is able to better cope with the load and
wont be DoS'ed near the project deadline.

An other advantage, stems from the fact that this server has been written with 
`rust + rocket` which is considered ok for prod whereas `flask` still warns 
against it. Plus, rust is a much safer language than python. Which means our
machine will not be used to mine bitcoins instead of serving cutom student corpora.

## Installation
Installing the server is a no brainer: all it takes is to compile the code and
then run it. Given this server is written, in rust, you will need to have the
compiler installed. I already took care of that part. But in case you need to
do it on another machine, here is how you install it: you can just follow the 
steps detailed on https://www.rust-lang.org/. Or you can simply execute the 
following line in your shell: 
```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

After that, the compilation is done with 
```
cargo build --release
```

That's it. Your compiled server is located in `$PROJECT/target/release/`

## Execution
Running the server is dead simple: you just execute the executable from a 
directory where `public/corpus/` is a folder containing the corpora that can
be customized. 

In order to make the service publicly available, and to make the server bind
a chosen port (port `80` for instance); the server uses two environment 
variables: `ROCKET_ADDRESS` and `ROCKET_PORT`. Hence the complete command to 
run would be: 
```
# ipv4
ROCKET_ADDRESS='0.0.0.0' ROCKET_PORT=80 nohup ./target/release/corpus_generator &

# ipv6
ROCKET_ADDRESS='::' ROCKET_PORT=80 nohup ./target/release/corpus_generator &
```

I personally find it a bit long to type that whole command whenever I need to
spawn the service, so I made a script for it. You may just as well decide to 
save some time and reuse that one.
```
./corpus.sh
```

## Techical Note
Because the VM on the INGI cloud use ipv6 only, and because github.com does not
support ipv6 at all, I did vendor all the dependency sources. This way the 
project can be built without requiring any access to the external world. Should
you change any of the dependency, and need to do the same; here is how you do it

```
# On your local machine, before scp onto the destination
cargo vendor

# Copy the few lines it tells you to in `.cargo/config.toml`
# You are now done: you can pack your application an upload it to your 
# ingi-cloud VM.
```

## IP6TABLES
Another common pitfall of deploying something onto the ingi cloud, is to 
configure the firewall. To that end, one instictively thinks of `iptables`
however, when the machine is an ipv6 machine; the firewall is configured 
through `ip6tables` instead.

```
# Drop everything 
ip6tables -P FORWARD DROP
ip6tables -P INPUT DROP
ip6tables -P OUTPUT DROP

# Allow session state tracking
ip6tables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ip6tables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
ip6tables -A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

# Open HTTP from everywhere
ip6tables -A FORWARD -m state --state NEW -p tcp --dport ssh -j ACCEPT
ip6tables -A FORWARD -m state --state NEW -p tcp --dport http -j ACCEPT

# Save
ip6tables-save -c
```
