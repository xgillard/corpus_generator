//! This is the micro service which generates the dynamic corpus for one given
//! student. A corpus is generated by issuing a request to:
//!
//! http:://{server}/linfo/corpus/<secret>/<corpus_id>/<size>/<username>
//!
//! Where:
//! * `{server}` stands for the ip address/dns name of the machine where
//!   this service is deployed.
//! * `<secret>` is a key which is changed each academic year (actually, it does
//!   not even need to be secret). Its purpose is to make sure that a student
//!   taking the same class and project several years in a row receives different
//!   corpora each year. This makes the inginous tasks easier to reuse over time.
//! * `<corpus_id>` is the name of a base corpus (one that has been placed in
//!   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
//!   if I want to generate a subset of the `public/corpus/p1_train.txt` base
//!   corpus, I need to specify the `p1_train` corpus key.
//! * `<size>` is the size (in number of lines) of the corpus you want to generate
//! * `<username>` is the name of the user whose corpus is to be generated.
//!
//! Author: X. Gillard
//! Date: September 29th, 2021

use std::io::Write;
use bzip2::{Compression, write::BzEncoder};

mod named_binary;
mod error;
mod corpus;

use crate::error::Result;
use crate::corpus::gen_corpus_data;
use crate::named_binary::{NamedBinary, NamedBinaryBuilder};

/// Returns the filename corresponding to a given corpus id
fn fname_from_corpus_id(corpus_id: &str) -> String {
    format!("public/corpus/{}.txt", corpus_id)
}

/// This is the implementation of the http endpoint that generates and 
/// compresses the customized corpus. This endpoint is mapped to: 
/// 
/// http:://{server}/linfo/corpus/<secret>/<corpus_id>/<size>/<username>
///
/// Where:
/// * `{server}` stands for the ip address/dns name of the machine where
///   this service is deployed.
/// * `<secret>` is a key which is changed each academic year (actually, it does
///   not even need to be secret). Its purpose is to make sure that a student
///   taking the same class and project several years in a row receives different
///   corpora each year. This makes the inginous tasks easier to reuse over time.
/// * `<corpus_id>` is the name of a base corpus (one that has been placed in
///   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
///   if I want to generate a subset of the `public/corpus/p1_train.txt` base
///   corpus, I need to specify the `p1_train` corpus key.
/// * `<size>` is the size (in number of lines) of the corpus you want to generate
/// * `<username>` is the name of the user whose corpus is to be generated.
///
#[rocket::get("/linfo2263/corpus/<secret>/<corpus_id>/<uname>/<size>")]
async fn gen_corpus(
    secret: &str,
    corpus_id: &str,
    uname: &str,
    size: usize,
) -> Result<NamedBinary> {

    let fname       = fname_from_corpus_id(corpus_id);
    let mut buffer  = vec![];
    let data        = gen_corpus_data(secret, &fname, uname, size).await?;
    let mut encoder = BzEncoder::new(&mut buffer, Compression::best());
    encoder.write_all(data.as_bytes())?;
    let gzipped   = encoder.finish()?;
    let responder = NamedBinaryBuilder::default()
        .content_type("application/bzip2")
        .download_name(format!("{}_{}.txt.bz2", corpus_id, uname))
        .payload(gzipped.to_vec())
        .build()?;
    Ok(responder)
}

/// This is the program's main entry point. It spawns the server whenever it 
/// gets run
#[rocket::main]
async fn main() {
    rocket::build()
        .mount("/", rocket::routes![gen_corpus])
        .launch()
        .await
        .expect("unexpected failure");
}
