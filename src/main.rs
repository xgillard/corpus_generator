//! This is the micro service which generates the dynamic corpus for one given
//! student. A corpus is generated by issuing a request to:
//!
//! http:://{server}/linfo/corpus/<secret>/<corpus_id>/<size>/<username>
//!
//! Where:
//! * `{server}` stands for the ip address/dns name of the machine where
//!   this service is deployed.
//! * `<secret>` is a key which is changed each academic year (actually, it does
//!   not even need to be secret). Its purpose is to make sure that a student
//!   taking the same class and project several years in a row receives different
//!   corpora each year. This makes the inginous tasks easier to reuse over time.
//! * `<corpus_id>` is the name of a base corpus (one that has been placed in
//!   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
//!   if I want to generate a subset of the `public/corpus/p1_train.txt` base
//!   corpus, I need to specify the `p1_train` corpus key.
//! * `<size>` is the size (in number of lines) of the corpus you want to generate
//! * `<username>` is the name of the user whose corpus is to be generated.
//!
//! Author: X. Gillard
//! Date: September 29th, 2021

use std::io::Write;
use bzip2::{Compression, write::BzEncoder};

mod named_binary;
mod error;
mod corpus;

use crate::error::Result;
use crate::corpus::gen_corpus_data;
use crate::named_binary::{NamedBinary, NamedBinaryBuilder};

use structopt::StructOpt;

/// This is the micro service which generates the dynamic corpus for one given
/// student. A corpus is generated by issuing a request to:
///
/// http:://{server}/bz2/<secret>/<corpus_id>/<username>/<size>/download.txt.bz2
///
/// or (to get the corpus in plain text rather than bz2)
///
/// http:://{server}/txt/<secret>/<corpus_id>/<username>/<size>/download.txt
///
/// Where:
/// * `{server}` stands for the ip address/dns name of the machine where
///   this service is deployed.
/// * `<secret>` is a key which is changed each academic year (actually, it does
///   not even need to be secret). Its purpose is to make sure that a student
///   taking the same class and project several years in a row receives different
///   corpora each year. This makes the inginous tasks easier to reuse over time.
/// * `<corpus_id>` is the name of a base corpus (one that has been placed in
///   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
///   if I want to generate a subset of the `public/corpus/p1_train.txt` base
///   corpus, I need to specify the `p1_train` corpus key.
/// * `<size>` is the size (in number of lines) of the corpus you want to generate
/// * `<username>` is the name of the user whose corpus is to be generated.
#[derive(StructOpt)]
struct Args {
    /// This is the directory where the service will go fetch the data that needs
    /// to be customized before being returned to the students
    #[structopt(long, short, default_value="public/corpus")]
    corpus_dir: String,
}

/// This is the global variable which is used to determine the directory 
/// where corpora are to be found. (Note: because the directory can be changed
/// through the command line; this variable has to be marked as mutable. 
/// However, since it is a global variable, this implies that any access to the
/// variable must occur within an `unsafe` block. Which is expected and totally
/// fine in this case).
static mut CORPUS_DIR : &str = "public/corpus";

/// Returns the filename corresponding to a given corpus id
fn fname_from_corpus_id(corpus_id: &str) -> String {
    // This block is marked 
    unsafe{
        format!("{}/{}.txt", CORPUS_DIR, corpus_id)
    }
}

/// This is the implementation of the http endpoint that generates and 
/// compresses the customized corpus. This endpoint is mapped to: 
/// 
/// http:://{server}/bz2/<secret>/<corpus_id>/<username>/<size>/download.txt.bz2
///
/// Where:
/// * `{server}` stands for the ip address/dns name of the machine where
///   this service is deployed.
/// * `<secret>` is a key which is changed each academic year (actually, it does
///   not even need to be secret). Its purpose is to make sure that a student
///   taking the same class and project several years in a row receives different
///   corpora each year. This makes the inginous tasks easier to reuse over time.
/// * `<corpus_id>` is the name of a base corpus (one that has been placed in
///   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
///   if I want to generate a subset of the `public/corpus/p1_train.txt` base
///   corpus, I need to specify the `p1_train` corpus key.
/// * `<size>` is the size (in number of lines) of the corpus you want to generate
/// * `<username>` is the name of the user whose corpus is to be generated.
///
#[rocket::get("/<secret>/<corpus_id>/<uname>/<size>/download.txt.bz2")]
async fn gen_corpus_bz2(
    secret: &str,
    corpus_id: &str,
    uname: &str,
    size: usize,
) -> Result<NamedBinary> {

    let fname       = fname_from_corpus_id(corpus_id);
    let mut buffer  = vec![];
    let data        = gen_corpus_data(secret, &fname, uname, size).await?;
    let mut encoder = BzEncoder::new(&mut buffer, Compression::best());
    encoder.write_all(data.as_bytes())?;
    let gzipped   = encoder.finish()?;
    let responder = NamedBinaryBuilder::default()
        .content_type("application/bzip2")
        .download_name(format!("{}_{}.txt.bz2", corpus_id, uname))
        .payload(gzipped.to_vec())
        .build()?;
    Ok(responder)
}

/// This is the implementation of the http endpoint that generates and 
/// compresses the customized corpus. This endpoint is mapped to: 
/// 
/// http:://{server}/txt/<secret>/<corpus_id>/<username>/<size>/download.txt
///
/// Where:
/// * `{server}` stands for the ip address/dns name of the machine where
///   this service is deployed.
/// * `<secret>` is a key which is changed each academic year (actually, it does
///   not even need to be secret). Its purpose is to make sure that a student
///   taking the same class and project several years in a row receives different
///   corpora each year. This makes the inginous tasks easier to reuse over time.
/// * `<corpus_id>` is the name of a base corpus (one that has been placed in
///   the `public/corpus` folder). **WITHOUT ITS .TXT EXTENSION**. For instance,
///   if I want to generate a subset of the `public/corpus/p1_train.txt` base
///   corpus, I need to specify the `p1_train` corpus key.
/// * `<size>` is the size (in number of lines) of the corpus you want to generate
/// * `<username>` is the name of the user whose corpus is to be generated.
///
#[rocket::get("/<secret>/<corpus_id>/<uname>/<size>/download.txt")]
async fn gen_corpus_txt(
    secret: &str,
    corpus_id: &str,
    uname: &str,
    size: usize,
) -> Result<String> {

    let fname = fname_from_corpus_id(corpus_id);
    let data  = gen_corpus_data(secret, &fname, uname, size).await?;
    Ok(data)
}

/// This is the program's main entry point. It spawns the server whenever it 
/// gets run
#[rocket::main]
async fn main() {
    // This is the short portion of code where I might write to the CORPUS_DIR
    // global variable. It happens **before** any request has a chance of 
    // getting processed. This is why this block is guaranteed to be safe
    unsafe {
        let args   = Args::from_args();
        let cdir   = Box::new(args.corpus_dir);
        CORPUS_DIR = Box::leak(cdir);
    }

    rocket::build()
        .mount("/bz2", rocket::routes![gen_corpus_bz2])
        .mount("/txt", rocket::routes![gen_corpus_txt])
        .launch()
        .await
        .expect("unexpected failure");
}
